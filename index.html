<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEET 2026 Daily Study Companion</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Custom font for better readability */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f0f4f8; /* Light background */
            color: #333;
        }
        /* Styling for the custom checkbox appearance */
        input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 24px;
            height: 24px;
            border: 2px solid #6366f1; /* Indigo 500 */
            border-radius: 6px; /* Rounded corners */
            position: relative;
            cursor: pointer;
            outline: none;
            transition: background-color 0.2s, border-color 0.2s;
        }
        input[type="checkbox"]:checked {
            background-color: #6366f1; /* Indigo 500 */
            border-color: #6366f1; /* Indigo 500 */
        }
        input[type="checkbox"]:checked::after {
            content: 'âœ“'; /* Checkmark symbol */
            color: white;
            font-size: 16px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
        }
        /* Style for the text areas to allow vertical resizing and auto-height */
        textarea {
            resize: vertical; /* Allow vertical resizing */
            min-height: 40px; /* Minimum height */
            height: auto; /* Auto height based on content */
            overflow-y: hidden; /* Hide scrollbar initially */
        }

        /* Tab button styling */
        .tab-button {
            padding: 10px 20px;
            border-bottom: 3px solid transparent;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #6b7280; /* Gray 500 */
        }
        .tab-button.active {
            border-color: #6366f1; /* Indigo 500 */
            color: #4338ca; /* Indigo 700 */
        }
        .tab-button:hover:not(.active) {
            color: #4f46e5; /* Indigo 600 */
        }

        /* Timer input styling (for setting time) */
        .timer-set-input {
            width: 60px;
            text-align: center;
            font-size: 1.25rem;
            border-radius: 8px;
            border: 1px solid #d1d5db;
            padding: 6px;
            margin: 0 5px;
            background-color: #f9fafb;
            color: #333;
        }
        .timer-set-input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }

        /* Modern Timer Display (Canvas Container) */
        .modern-timer-container {
            position: relative;
            width: 250px; /* Fixed size for the circle */
            height: 250px;
            margin: 0 auto 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modern-timer-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .modern-timer-text {
            position: relative; /* To be above canvas */
            font-size: 3.5rem; /* Large text for time */
            font-weight: 800;
            color: #4338ca;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        /* Modern Button Styles */
        .modern-button {
            padding: 0.8rem 2rem;
            border-radius: 9999px; /* Fully rounded */
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08); /* Soft shadow */
            transition: all 0.3s ease;
            background-size: 200% auto; /* For gradient animation */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .modern-button:hover {
            background-position: right center; /* Move gradient on hover */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05); /* Larger shadow on hover */
            transform: translateY(-2px); /* Slight lift */
        }

        .modern-button.start {
            background-image: linear-gradient(to right, #10b981 0%, #059669 50%, #10b981 100%); /* Green gradient */
            color: white;
        }
        .modern-button.pause {
            background-image: linear-gradient(to right, #f59e0b 0%, #d97706 50%, #f59e0b 100%); /* Yellow/orange gradient */
            color: white;
        }
        .modern-button.reset {
            background-image: linear-gradient(to right, #ef4444 0%, #dc2626 50%, #ef4444 100%); /* Red gradient */
            color: white;
        }

        .modern-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Progress Chart Styling */
        .progress-chart-container {
            position: relative;
            width: 100%;
            height: 350px; /* Fixed height for chart */
            margin-bottom: 1.5rem;
        }
        .progress-chart-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="p-4 sm:p-6 md:p-8 lg:p-10 bg-gray-100 min-h-screen flex items-center justify-center">
    <div class="container mx-auto bg-white shadow-lg rounded-xl p-6 sm:p-8 md:p-10 max-w-4xl w-full">
        <h1 class="text-3xl sm:text-4xl font-bold text-center text-indigo-700 mb-8">Your Daily NEET 2026 Study Companion</h1>

        <!-- Tab Navigation -->
        <div class="flex justify-center mb-6 border-b border-gray-200">
            <button id="checklistTabBtn" class="tab-button active">Checklist</button>
            <button id="timerTabBtn" class="tab-button">Timer</button>
            <button id="progressTabBtn" class="tab-button">Progress</button>
        </div>

        <!-- Checklist Section -->
        <div id="checklistSection" class="tab-content">
            <div class="mb-10">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 border-b-2 border-indigo-300 pb-2">Daily Study Tasks</h2>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200 rounded-lg overflow-hidden">
                        <thead class="bg-indigo-100">
                            <tr>
                                <th scope="col" class="px-3 py-3 text-left text-xs font-medium text-indigo-700 uppercase tracking-wider rounded-tl-lg">Category</th>
                                <th scope="col" class="px-3 py-3 text-left text-xs font-medium text-indigo-700 uppercase tracking-wider">Task Description</th>
                                <th scope="col" class="px-3 py-3 text-center text-xs font-medium text-indigo-700 uppercase tracking-wider">Status</th>
                                <th scope="col" class="px-3 py-3 text-left text-xs font-medium text-indigo-700 uppercase tracking-wider">Notes / Topics Covered</th>
                                <th scope="col" class="px-3 py-3 text-center text-xs font-medium text-indigo-700 uppercase tracking-wider rounded-tr-lg">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200" id="studyTasksTableBody">
                            <!-- Tasks will be dynamically loaded here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div>
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 border-b-2 border-indigo-300 pb-2">End of Day Activities</h2>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200 rounded-lg overflow-hidden">
                        <thead class="bg-indigo-100">
                            <tr>
                                <th scope="col" class="px-3 py-3 text-left text-xs font-medium text-indigo-700 uppercase tracking-wider rounded-tl-lg">Category</th>
                                <th scope="col" class="px-3 py-3 text-left text-xs font-medium text-indigo-700 uppercase tracking-wider">Task Description</th>
                                <th scope="col" class="px-3 py-3 text-center text-xs font-medium text-indigo-700 uppercase tracking-wider">Status</th>
                                <th scope="col" class="px-3 py-3 text-left text-xs font-medium text-indigo-700 uppercase tracking-wider">Notes / Reflection</th>
                                <th scope="col" class="px-3 py-3 text-center text-xs font-medium text-indigo-700 uppercase tracking-wider rounded-tr-lg">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200" id="endOfDayTasksTableBody">
                            <!-- Tasks will be dynamically loaded here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- New Add Task UI -->
            <div class="mt-6 flex flex-col sm:flex-row items-center justify-center gap-4 p-4 bg-gray-50 rounded-lg shadow-inner">
                <label for="newTaskCategory" class="text-gray-700 font-medium whitespace-nowrap">Add New Task:</label>
                <select id="newTaskCategory" class="flex-grow sm:flex-grow-0 border rounded-md p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="Physics">Physics</option>
                    <option value="Chemistry">Chemistry</option>
                    <option value="Biology">Biology</option>
                    <option value="Self-Test">Self-Test</option>
                    <option value="Prouds">Prouds</option>
                    <option value="Regrets">Regrets</option>
                    <option value="Improvement Needed?">Improvement Needed?</option>
                    <option value="Other Study Task">Other Study Task</option>
                    <option value="Other End of Day Activity">Other End of Day Activity</option>
                </select>
                <button id="addNewTaskBtn" class="modern-button start px-4 py-2 text-sm"><i class="fas fa-plus"></i> Add Task</button>
            </div>

            <p class="text-center text-gray-600 text-sm mt-8">
                **How to use the Status column:** Click the checkbox next to each task to mark it as completed (âœ“) or uncompleted (empty).
            </p>
        </div>

        <!-- Timer Section -->
        <div id="timerSection" class="tab-content hidden p-6 text-center bg-gradient-to-br from-indigo-50 to-blue-100 rounded-lg shadow-xl">
            <h2 class="text-3xl font-extrabold text-indigo-800 mb-8">Study Timer</h2>

            <div class="flex justify-center items-center mb-6">
                <input type="number" id="minutesInput" class="timer-set-input" value="25" min="0" max="99">
                <span class="text-2xl font-bold mx-1 text-indigo-700">:</span>
                <input type="number" id="secondsInput" class="timer-set-input" value="00" min="0" max="59">
            </div>

            <div class="modern-timer-container">
                <canvas id="timerCanvas" class="modern-timer-canvas"></canvas>
                <div id="timerDisplay" class="modern-timer-text">25:00</div>
            </div>

            <div class="flex justify-center space-x-6">
                <button id="startTimerBtn" class="modern-button start"><i class="fas fa-play"></i> Start</button>
                <button id="pauseTimerBtn" class="modern-button pause" disabled><i class="fas fa-pause"></i> Pause</button>
                <button id="resetTimerBtn" class="modern-button reset" disabled><i class="fas fa-redo"></i> Reset</button>
            </div>
        </div>

        <!-- Progress Section -->
        <div id="progressSection" class="tab-content hidden p-6 text-center bg-gradient-to-br from-purple-50 to-pink-100 rounded-lg shadow-xl">
            <h2 class="text-3xl font-extrabold text-purple-800 mb-6">Progress Tracker</h2>

            <!-- Progress Tab Navigation -->
            <div class="flex justify-center mb-6 border-b border-gray-200">
                <button id="dailyProgressTabBtn" class="tab-button active">Daily</button>
                <button id="weeklyProgressTabBtn" class="tab-button">Weekly</button>
                <button id="monthlyProgressTabBtn" class="tab-button">Monthly</button>
            </div>

            <div class="progress-chart-container">
                <canvas id="progressChart" class="progress-chart-canvas bg-white rounded-lg shadow-md p-4"></canvas>
            </div>
            <button id="clearProgressHistoryBtn" class="modern-button reset bg-red-600 hover:bg-red-700 text-white"><i class="fas fa-trash-alt"></i> Clear Progress History</button>
        </div>
    </div>

    <script>
        // --- Constants for Local Storage Keys ---
        const CHECKLIST_STORAGE_KEY = 'neetChecklistState';
        const LAST_RESET_DATE_KEY = 'neetLastResetDate';
        const DAILY_PROGRESS_KEY = 'neetDailyProgress';
        const TIMER_STORAGE_KEY = 'neetTimerState';

        // --- Default Checklist Template ---
        // This template is used only if no checklist data is found in localStorage
        const DEFAULT_CHECKLIST_TEMPLATE = [
            { section: 'study', subject: 'Physics', description: 'Lec and notes together', taskId: 'physics-lec-notes' },
            { section: 'study', subject: 'Physics', description: 'Revise notes and practise class questions again', taskId: 'physics-revise-class-qs' },
            { section: 'study', subject: 'Physics', description: 'DPP and Module', taskId: 'physics-dpp-module' },
            { section: 'study', subject: 'Physics', description: 'KPP and Extra Book questions', taskId: 'physics-kpp-extra-book' },
            { section: 'study', subject: 'Physics', description: 'MahaManthan Assignment (if given) and HCV lookup', taskId: 'physics-mahamanthan-hcv' },
            { section: 'study', subject: 'Chemistry', description: 'Lec and notes together', taskId: 'chemistry-lec-notes' },
            { section: 'study', subject: 'Chemistry', description: 'Revise notes, Read NCERT and practise class questions again', taskId: 'chemistry-revise-ncert-class-qs' },
            { section: 'study', subject: 'Chemistry', description: 'DPP and Module', taskId: 'chemistry-dpp-module' },
            { section: 'study', subject: 'Chemistry', description: 'Extra Book questions', taskId: 'chemistry-extra-book' },
            { section: 'study', subject: 'Chemistry', description: 'High Level Question atleast 2/3 per day', taskId: 'chemistry-high-level-qs' },
            { section: 'study', subject: 'Biology', description: 'Lec and notes together', taskId: 'biology-lec-notes' },
            { section: 'study', subject: 'Biology', description: 'Revise notes, Read NCERT and practise class questions again', taskId: 'biology-revise-ncert-class-qs' },
            { section: 'study', subject: 'Biology', description: 'DPP and Module', taskId: 'biology-dpp-module' },
            { section: 'study', subject: 'Biology', description: 'Extra Book questions', taskId: 'biology-extra-book' },
            { section: 'study', subject: 'Biology', description: 'NCERT word to Word / Line to Line Questions', taskId: 'biology-ncert-word-to-word' },
            { section: 'endOfDay', subject: 'Self-Test', description: 'Small test of previous days topics (9:00 PM - 10:00 PM)', taskId: 'self-test' },
            { section: 'endOfDay', subject: 'Prouds', description: '', taskId: 'sum-up-prouds' },
            { section: 'endOfDay', subject: 'Regrets', description: '', taskId: 'sum-up-regrets' },
            { section: 'endOfDay', subject: 'Improvement Needed?', description: '', taskId: 'sum-up-improvement' }
        ];

        // --- Common Functions ---

        // Auto-resize textareas based on content
        function setupTextareaAutoResize(textarea) {
            textarea.addEventListener('input', () => {
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
                saveChecklistState(); // Save state on textarea input
            });
            // Initial resize in case content is pre-filled
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight) + 'px';
        }

        // --- Tab Switching Logic ---
        const checklistTabBtn = document.getElementById('checklistTabBtn');
        const timerTabBtn = document.getElementById('timerTabBtn');
        const progressTabBtn = document.getElementById('progressTabBtn');
        const checklistSection = document.getElementById('checklistSection');
        const timerSection = document.getElementById('timerSection');
        const progressSection = document.getElementById('progressSection');

        const dailyProgressTabBtn = document.getElementById('dailyProgressTabBtn');
        const weeklyProgressTabBtn = document.getElementById('weeklyProgressTabBtn');
        const monthlyProgressTabBtn = document.getElementById('monthlyProgressTabBtn');

        let currentProgressView = 'daily'; // Default progress view

        function showTab(tabName) {
            // Hide all sections
            checklistSection.classList.add('hidden');
            timerSection.classList.add('hidden');
            progressSection.classList.add('hidden');

            // Deactivate all main tab buttons
            checklistTabBtn.classList.remove('active');
            timerTabBtn.classList.remove('active');
            progressTabBtn.classList.remove('active');

            // Show the selected section and activate its button
            if (tabName === 'checklist') {
                checklistSection.classList.remove('hidden');
                checklistTabBtn.classList.add('active');
            } else if (tabName === 'timer') {
                timerSection.classList.remove('hidden');
                timerTabBtn.classList.add('active');
                // Ensure timer canvas is drawn when tab is active
                drawTimerCircle(timerCtx, timeRemaining, initialMinutes * 60 + initialSeconds);
            } else if (tabName === 'progress') {
                progressSection.classList.remove('hidden');
                progressTabBtn.classList.add('active');
                showProgressView(currentProgressView); // Render chart for current view
            }
        }

        function showProgressView(view) {
            currentProgressView = view;
            dailyProgressTabBtn.classList.remove('active');
            weeklyProgressTabBtn.classList.remove('active');
            monthlyProgressTabBtn.classList.remove('active');

            if (view === 'daily') {
                dailyProgressTabBtn.classList.add('active');
            } else if (view === 'weekly') {
                weeklyProgressTabBtn.classList.add('active');
            } else if (view === 'monthly') {
                monthlyProgressTabBtn.classList.add('active');
            }
            renderProgressChart(currentProgressView);
        }

        checklistTabBtn.addEventListener('click', () => showTab('checklist'));
        timerTabBtn.addEventListener('click', () => showTab('timer'));
        progressTabBtn.addEventListener('click', () => showTab('progress'));

        dailyProgressTabBtn.addEventListener('click', () => showProgressView('daily'));
        weeklyProgressTabBtn.addEventListener('click', () => showProgressView('weekly'));
        monthlyProgressTabBtn.addEventListener('click', () => showProgressView('monthly'));

        // --- Checklist Logic (with Local Storage and Daily Reset) ---

        // Function to create a new task row HTML element
        function createTaskRow(taskData) {
            const row = document.createElement('tr');
            row.dataset.taskId = taskData.taskId;
            row.dataset.section = taskData.section; // Store section (study/endOfDay)
            row.dataset.subject = taskData.subject; // Store subject (Physics, Self-Test, etc.)

            // Determine the initial description placeholder/value
            let descriptionValue = taskData.description || '';
            let placeholderText = 'Task Description';

            if (taskData.subject === 'Prouds' || taskData.subject === 'Regrets' || taskData.subject === 'Improvement Needed?') {
                placeholderText = taskData.subject; // Use subject as placeholder for these
            } else if (taskData.subject === 'Self-Test') {
                placeholderText = 'Topics tested:';
            }


            row.innerHTML = `
                <td class="px-3 py-4 whitespace-nowrap font-semibold text-indigo-600">${taskData.subject}</td>
                <td class="px-3 py-4">
                    <textarea class="w-full border rounded-md p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500 task-description-input" placeholder="${placeholderText}">${descriptionValue}</textarea>
                </td>
                <td class="px-3 py-4 text-center"><input type="checkbox" class="task-checkbox rounded-md"></td>
                <td class="px-3 py-4">
                    <textarea class="w-full border rounded-md p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500 task-notes-input" placeholder="Notes">${taskData.notes || ''}</textarea>
                </td>
                <td class="px-3 py-4 text-center">
                    <button class="remove-task-btn bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-2 rounded-md text-sm rounded-full"><i class="fas fa-trash-alt"></i></button>
                </td>
            `;

            // Set checkbox state
            const checkbox = row.querySelector('.task-checkbox');
            if (checkbox) {
                checkbox.checked = taskData.checked || false;
                checkbox.addEventListener('change', saveChecklistState);
            }

            // Setup auto-resize and save for notes textarea
            const notesTextarea = row.querySelector('.task-notes-input');
            if (notesTextarea) {
                setupTextareaAutoResize(notesTextarea);
            }

            // Setup auto-resize and save for description textarea
            const descriptionTextarea = row.querySelector('.task-description-input');
            if (descriptionTextarea) {
                setupTextareaAutoResize(descriptionTextarea);
                descriptionTextarea.addEventListener('input', saveChecklistState); // Save on description change
            }

            // Add remove button functionality
            const removeButton = row.querySelector('.remove-task-btn');
            if (removeButton) {
                removeButton.addEventListener('click', () => {
                    if (confirm('Are you sure you want to remove this task?')) {
                        row.remove();
                        saveChecklistState(); // Save state after removing
                    }
                });
            }

            return row;
        }

        // Function to add a new task (triggered by "Add Task" button)
        const newTaskCategorySelect = document.getElementById('newTaskCategory');
        const addNewTaskBtn = document.getElementById('addNewTaskBtn');

        addNewTaskBtn.addEventListener('click', () => {
            const selectedSubject = newTaskCategorySelect.value;
            const newTaskId = `custom-task-${Date.now()}`; // Unique ID for new tasks

            let section = 'study'; // Default section
            // Determine section based on selected subject
            if (['Self-Test', 'Prouds', 'Regrets', 'Improvement Needed?', 'Other End of Day Activity'].includes(selectedSubject)) {
                section = 'endOfDay';
            }

            const newTaskData = {
                section: section,
                subject: selectedSubject,
                description: '', // Empty description for new tasks
                taskId: newTaskId,
                checked: false,
                notes: ''
            };
            const newRow = createTaskRow(newTaskData);

            if (section === 'study') {
                document.getElementById('studyTasksTableBody').appendChild(newRow);
            } else if (section === 'endOfDay') {
                document.getElementById('endOfDayTasksTableBody').appendChild(newRow);
            }
            saveChecklistState(); // Save state after adding
            newRow.querySelector('.task-description-input').focus(); // Focus on new task description
        });


        // Function to save the checklist state to localStorage
        function saveChecklistState() {
            const checklistState = {};
            document.querySelectorAll('#studyTasksTableBody tr, #endOfDayTasksTableBody tr').forEach((row) => {
                const taskId = row.dataset.taskId;
                const section = row.dataset.section;
                const subject = row.dataset.subject;
                if (taskId && section && subject) {
                    const checkbox = row.querySelector('.task-checkbox');
                    const descriptionTextarea = row.querySelector('.task-description-input');
                    const notesTextarea = row.querySelector('.task-notes-input');

                    checklistState[taskId] = {
                        section: section,
                        subject: subject,
                        description: descriptionTextarea ? descriptionTextarea.value : '',
                        checked: checkbox ? checkbox.checked : false,
                        notes: notesTextarea ? notesTextarea.value : ''
                    };
                }
            });
            localStorage.setItem(CHECKLIST_STORAGE_KEY, JSON.stringify(checklistState));
            // console.log("Checklist state saved to localStorage.");
        }

        // Function to record previous day's progress before resetting
        function recordPreviousDayProgress(dateToRecord) {
            const previousDayChecklistState = JSON.parse(localStorage.getItem(CHECKLIST_STORAGE_KEY) || '{}');
            let completedTasks = 0;
            let totalTasks = 0;

            for (const taskId in previousDayChecklistState) {
                totalTasks++; // Count all tasks in the saved state
                if (previousDayChecklistState[taskId].checked) {
                    completedTasks++;
                }
            }

            // Get existing daily progress or initialize
            const dailyProgress = JSON.parse(localStorage.getItem(DAILY_PROGRESS_KEY) || '{}');
            
            // Only record if there were tasks in the checklist for that day
            if (totalTasks > 0) {
                dailyProgress[dateToRecord] = {
                    completed: completedTasks,
                    total: totalTasks
                };
                localStorage.setItem(DAILY_PROGRESS_KEY, JSON.stringify(dailyProgress));
                console.log(`Recorded progress for ${dateToRecord}: ${completedTasks}/${totalTasks} tasks completed.`);
            } else {
                console.log(`No tasks recorded for ${dateToRecord}. Skipping progress save.`);
            }
        }

        // Function to load the checklist state from localStorage or default template
        function loadChecklistState() {
            const todayDate = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
            const lastResetDate = localStorage.getItem(LAST_RESET_DATE_KEY);

            if (lastResetDate && lastResetDate !== todayDate) {
                // It's a new day, record previous day's progress and then reset
                recordPreviousDayProgress(lastResetDate);
                localStorage.removeItem(CHECKLIST_STORAGE_KEY); // Clear previous day's checklist
                localStorage.setItem(LAST_RESET_DATE_KEY, todayDate); // Set new reset date
                console.log("Checklist reset for a new day and previous day's progress recorded.");
            } else if (!lastResetDate) {
                // First time loading, set the reset date
                localStorage.setItem(LAST_RESET_DATE_KEY, todayDate);
                console.log("First load, setting daily reset date.");
            }

            // Clear existing rows from the DOM before loading
            document.getElementById('studyTasksTableBody').innerHTML = '';
            document.getElementById('endOfDayTasksTableBody').innerHTML = '';

            const savedState = localStorage.getItem(CHECKLIST_STORAGE_KEY);
            let checklistData = {};

            if (savedState) {
                checklistData = JSON.parse(savedState);
            } else {
                // If no saved state, use the default template
                DEFAULT_CHECKLIST_TEMPLATE.forEach(task => {
                    checklistData[task.taskId] = { ...task, checked: false, notes: '' };
                });
            }

            // Populate the checklist based on loaded or default data
            for (const taskId in checklistData) {
                const task = checklistData[taskId];
                const newRow = createTaskRow(task);
                if (task.section === 'study') {
                    document.getElementById('studyTasksTableBody').appendChild(newRow);
                } else if (task.section === 'endOfDay') {
                    document.getElementById('endOfDayTasksTableBody').appendChild(newRow);
                }
            }
            saveChecklistState(); // Ensure the current state (including default if no saved) is saved
        }

        // --- Timer Logic (with Local Storage and Circular UI) ---
        const minutesInput = document.getElementById('minutesInput');
        const secondsInput = document.getElementById('secondsInput');
        const timerDisplay = document.getElementById('timerDisplay');
        const startTimerBtn = document.getElementById('startTimerBtn');
        const pauseTimerBtn = document.getElementById('pauseTimerBtn');
        const resetTimerBtn = document.getElementById('resetTimerBtn');
        const timerCanvas = document.getElementById('timerCanvas');
        const timerCtx = timerCanvas.getContext('2d');

        let timerInterval;
        let timeRemaining = 0; // in seconds
        let isTimerRunning = false;
        let initialMinutes = 25;
        let initialSeconds = 0;
        let totalTimerSeconds = 0; // Total seconds for the current timer session

        // Audio context for sound
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Function to play a simple beep sound
        function playAlarm() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = 440; // A4 note
            gainNode.gain.setValueAtTime(1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1); // Fade out

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 1);
        }

        function drawTimerCircle(ctx, currentSeconds, totalSeconds) {
            // Ensure canvas dimensions are set before drawing
            timerCanvas.width = timerCanvas.offsetWidth;
            timerCanvas.height = timerCanvas.offsetHeight;

            const centerX = timerCanvas.width / 2;
            const centerY = timerCanvas.height / 2;
            const radius = Math.min(centerX, centerY) - 10; // Adjust radius for padding

            ctx.clearRect(0, 0, timerCanvas.width, timerCanvas.height);

            // Background circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#e2e8f0'; /* Gray 200 */
            ctx.lineWidth = 10;
            ctx.stroke();

            // Progress arc
            if (totalSeconds > 0) {
                const startAngle = -Math.PI / 2; // Start from top
                const endAngle = startAngle + (currentSeconds / totalSeconds) * (2 * Math.PI);

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.strokeStyle = '#6366f1'; /* Indigo 500 */
                ctx.lineWidth = 10;
                ctx.stroke();
            }
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.title = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')} - Study Timer`;
            drawTimerCircle(timerCtx, timeRemaining, totalTimerSeconds);
        }

        function saveTimerState() {
            const timerState = {
                timeRemaining: timeRemaining,
                isTimerRunning: isTimerRunning,
                initialMinutes: initialMinutes,
                initialSeconds: initialSeconds,
                totalTimerSeconds: totalTimerSeconds,
                lastUpdated: Date.now() // Save timestamp for more accurate resume
            };
            localStorage.setItem(TIMER_STORAGE_KEY, JSON.stringify(timerState));
            // console.log("Timer state saved to localStorage.");
        }

        function loadTimerState() {
            const savedState = localStorage.getItem(TIMER_STORAGE_KEY);
            if (savedState) {
                const timerState = JSON.parse(savedState);
                initialMinutes = timerState.initialMinutes || 25;
                initialSeconds = timerState.initialSeconds || 0;
                totalTimerSeconds = timerState.totalTimerSeconds || (initialMinutes * 60 + initialSeconds);
                isTimerRunning = timerState.isTimerRunning || false;
                timeRemaining = timerState.timeRemaining || totalTimerSeconds;

                minutesInput.value = initialMinutes.toString().padStart(2, '0');
                secondsInput.value = initialSeconds.toString().padStart(2, '0');

                if (isTimerRunning) {
                    const timeElapsedSinceLastUpdate = Math.floor((Date.now() - timerState.lastUpdated) / 1000);
                    timeRemaining = Math.max(0, timeRemaining - timeElapsedSinceLastUpdate);
                    if (timeRemaining <= 0) {
                        isTimerRunning = false; // Timer finished while app was closed
                        playAlarm();
                    }
                }
                updateTimerDisplay(); // Initial draw
                if (isTimerRunning) {
                    startTimer(); // Resume timer if it was running
                }
            } else {
                // If no saved state, set initial values and draw
                totalTimerSeconds = initialMinutes * 60 + initialSeconds;
                timeRemaining = totalTimerSeconds;
                updateTimerDisplay();
            }
            // Ensure buttons are correctly enabled/disabled on load
            startTimerBtn.disabled = isTimerRunning || (timeRemaining <= 0 && totalTimerSeconds <= 0);
            pauseTimerBtn.disabled = !isTimerRunning;
            resetTimerBtn.disabled = isTimerRunning || (timeRemaining === totalTimerSeconds);
            minutesInput.disabled = isTimerRunning;
            secondsInput.disabled = isTimerRunning;
        }

        function startTimer() {
            if (isTimerRunning) return;

            // If timeRemaining is 0, set it from inputs
            if (timeRemaining <= 0) {
                initialMinutes = parseInt(minutesInput.value) || 0;
                initialSeconds = parseInt(secondsInput.value) || 0;
                totalTimerSeconds = initialMinutes * 60 + initialSeconds;
                timeRemaining = totalTimerSeconds;
                if (timeRemaining <= 0) {
                    alert("Please set a valid time for the timer.");
                    return;
                }
            }

            isTimerRunning = true;
            startTimerBtn.disabled = true;
            pauseTimerBtn.disabled = false;
            resetTimerBtn.disabled = false;
            minutesInput.disabled = true;
            secondsInput.disabled = true;

            timerInterval = setInterval(() => {
                timeRemaining--;
                // Ensure timeRemaining does not go below 0
                if (timeRemaining < 0) {
                    timeRemaining = 0;
                }
                updateTimerDisplay();

                if (timeRemaining === 0) { // Check for exact 0
                    clearInterval(timerInterval);
                    isTimerRunning = false;
                    startTimerBtn.disabled = false;
                    pauseTimerBtn.disabled = true;
                    minutesInput.disabled = false;
                    secondsInput.disabled = false;
                    playAlarm();
                    // updateTimerDisplay() already called just before this
                    saveTimerState(); // Save final state
                } else {
                    saveTimerState(); // Save state during countdown
                }
            }, 1000);
        }

        function pauseTimer() {
            clearInterval(timerInterval);
            isTimerRunning = false;
            startTimerBtn.disabled = false;
            pauseTimerBtn.disabled = true;
            minutesInput.disabled = false;
            secondsInput.disabled = false;
            saveTimerState(); // Save state when paused
        }

        function resetTimer() {
            clearInterval(timerInterval);
            isTimerRunning = false;
            timeRemaining = totalTimerSeconds; // Reset to initial set time
            updateTimerDisplay();
            startTimerBtn.disabled = false;
            pauseTimerBtn.disabled = true;
            resetTimerBtn.disabled = true;
            minutesInput.disabled = false;
            secondsInput.disabled = false;
            saveTimerState(); // Save reset state
        }

        // Event listeners for timer controls
        startTimerBtn.addEventListener('click', startTimer);
        pauseTimerBtn.addEventListener('click', pauseTimer);
        resetTimerBtn.addEventListener('click', resetTimer);

        // Input change listeners for minutes/seconds to update initial values
        minutesInput.addEventListener('input', () => {
            initialMinutes = parseInt(minutesInput.value) || 0;
            totalTimerSeconds = initialMinutes * 60 + (parseInt(secondsInput.value) || 0);
            if (!isTimerRunning) { // Only update display if timer is not running
                timeRemaining = totalTimerSeconds;
                updateTimerDisplay();
            }
            saveTimerState(); // Save initial set time
            resetTimerBtn.disabled = (timeRemaining === totalTimerSeconds); // Enable reset if inputs change
        });
        secondsInput.addEventListener('input', () => {
            initialSeconds = parseInt(secondsInput.value) || 0;
            totalTimerSeconds = (parseInt(minutesInput.value) || 0) * 60 + initialSeconds;
            if (!isTimerRunning) { // Only update display if timer is not running
                timeRemaining = totalTimerSeconds;
                updateTimerDisplay();
            }
            saveTimerState(); // Save initial set time
            resetTimerBtn.disabled = (timeRemaining === totalTimerSeconds); // Enable reset if inputs change
        });

        // --- Progress Tracking Logic ---
        const progressChartCanvas = document.getElementById('progressChart');
        const clearProgressHistoryBtn = document.getElementById('clearProgressHistoryBtn');
        const ctx = progressChartCanvas.getContext('2d');

        function getWeekNumber(d) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return weekNo;
        }

        function getMonthName(dateString) {
            const date = new Date(dateString);
            return date.toLocaleString('en-US', { month: 'short', year: 'numeric' }); // e.g., Jul 2024
        }

        function renderProgressChart(timeframe) {
            const dailyProgress = JSON.parse(localStorage.getItem(DAILY_PROGRESS_KEY) || '{}');
            let chartLabels = [];
            let chartData = [];
            let maxYValue = 0; // Max value for the Y-axis

            // Helper to get total possible tasks from the current checklist structure
            const getCurrentTotalTasks = () => {
                let total = 0;
                const checklistState = JSON.parse(localStorage.getItem(CHECKLIST_STORAGE_KEY) || '{}');
                for (const taskId in checklistState) {
                    total++;
                }
                return total > 0 ? total : DEFAULT_CHECKLIST_TEMPLATE.length; // Fallback to default template count
            };

            if (timeframe === 'daily') {
                // For daily, show last 7 days
                for (let i = 0; i < 7; i++) {
                    const d = new Date();
                    d.setDate(d.getDate() - (6 - i));
                    const dateString = d.toISOString().slice(0, 10);
                    const progress = dailyProgress[dateString];

                    chartLabels.push(dateString.slice(5)); // MM-DD
                    chartData.push(progress ? progress.completed : 0);
                    if (progress) maxYValue = Math.max(maxYValue, progress.total);
                }
            } else if (timeframe === 'weekly') {
                // For weekly, show last 8 weeks (current week + 7 previous)
                const weeklyAggregated = {};
                const sortedDates = Object.keys(dailyProgress).sort();

                sortedDates.forEach(dateString => {
                    const date = new Date(dateString);
                    const year = date.getFullYear();
                    const week = getWeekNumber(date);
                    const weekKey = `${year}-W${week.toString().padStart(2, '0')}`;

                    if (!weeklyAggregated[weekKey]) {
                        weeklyAggregated[weekKey] = { completed: 0, total: 0 };
                    }
                    weeklyAggregated[weekKey].completed += dailyProgress[dateString].completed;
                    weeklyAggregated[weekKey].total += dailyProgress[dateString].total;
                });

                // Get keys for the last 8 weeks, including the current week
                const today = new Date();
                let weeksToShow = [];
                for (let i = 7; i >= 0; i--) { // Iterate backwards from current week to 7 weeks ago
                    let d = new Date(today);
                    d.setDate(d.getDate() - (i * 7)); // Go back i full weeks
                    const year = d.getFullYear();
                    const week = getWeekNumber(d);
                    weeksToShow.push(`${year}-W${week.toString().padStart(2, '0')}`);
                }
                weeksToShow = [...new Set(weeksToShow)].sort(); // Remove duplicates and sort

                for (const weekKey of weeksToShow) {
                    chartLabels.push(`W${weekKey.split('-W')[1]}`);
                    const data = weeklyAggregated[weekKey];
                    chartData.push(data ? data.completed : 0);
                    if (data) maxYValue = Math.max(maxYValue, data.total);
                }

            } else if (timeframe === 'monthly') {
                // For monthly, show last 6 months
                const monthlyAggregated = {};
                const sortedDates = Object.keys(dailyProgress).sort();

                sortedDates.forEach(dateString => {
                    const date = new Date(dateString);
                    const monthKey = `${date.getFullYear()}-${date.getMonth()}`; // Year-Month index

                    if (!monthlyAggregated[monthKey]) {
                        monthlyAggregated[monthKey] = { completed: 0, total: 0 };
                    }
                    monthlyAggregated[monthKey].completed += dailyProgress[dateString].completed;
                    monthlyAggregated[monthKey].total += dailyProgress[dateString].total;
                });

                // Get keys for the last 6 months, including the current month
                const today = new Date();
                let monthsToShow = [];
                for (let i = 5; i >= 0; i--) { // Iterate backwards from current month to 5 months ago
                    let d = new Date(today);
                    d.setMonth(d.getMonth() - i);
                    const monthKey = `${d.getFullYear()}-${d.getMonth()}`;
                    monthsToShow.push(monthKey);
                }
                monthsToShow = [...new Set(monthsToShow)].sort((a, b) => {
                    const [y1, m1] = a.split('-').map(Number);
                    const [y2, m2] = b.split('-').map(Number);
                    if (y1 !== y2) return y1 - y2;
                    return m1 - m2;
                });

                for (const monthKey of monthsToShow) {
                    const d = new Date(parseInt(monthKey.split('-')[0]), parseInt(monthKey.split('-')[1]), 1);
                    chartLabels.push(getMonthName(d.toISOString().slice(0, 10)));
                    const data = monthlyAggregated[monthKey];
                    chartData.push(data ? data.completed : 0);
                    if (data) maxYValue = Math.max(maxYValue, data.total);
                }
            }

            // Fallback for maxYValue if no data or aggregated data has no total
            if (maxYValue === 0) {
                maxYValue = getCurrentTotalTasks();
            }
            if (maxYValue === 0) maxYValue = 1; // Ensure it's at least 1 to avoid division by zero


            // Clear canvas
            ctx.clearRect(0, 0, progressChartCanvas.width, progressChartCanvas.height);

            // Set canvas size for responsiveness
            progressChartCanvas.width = progressChartCanvas.offsetWidth;
            progressChartCanvas.height = progressChartCanvas.offsetHeight || 350; // Default height if not set by CSS

            const chartPadding = 60;
            const chartWidth = progressChartCanvas.width - chartPadding * 2;
            const chartHeight = progressChartCanvas.height - chartPadding * 2;

            const barCount = chartData.length;
            if (barCount === 0) {
                ctx.fillStyle = '#6b7280';
                ctx.font = '16px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('No data available to display.', progressChartCanvas.width / 2, progressChartCanvas.height / 2);
                return;
            }

            const barActualWidth = Math.max(10, chartWidth / (barCount * 1.5)); // Ensure min width
            const barSpacing = (chartWidth - (barActualWidth * barCount)) / (barCount - 1 || 1); // Space between bars

            // Draw Y-axis
            ctx.beginPath();
            ctx.moveTo(chartPadding, chartPadding);
            ctx.lineTo(chartPadding, chartHeight + chartPadding);
            ctx.strokeStyle = '#ccc';
            ctx.stroke();

            // Draw X-axis
            ctx.beginPath();
            ctx.moveTo(chartPadding, chartHeight + chartPadding);
            ctx.lineTo(chartWidth + chartPadding, chartHeight + chartPadding);
            ctx.strokeStyle = '#ccc';
            ctx.stroke();

            // Draw bars
            for (let i = 0; i < barCount; i++) {
                const barValue = chartData[i];
                const barHeight = (barValue / maxYValue) * chartHeight;
                const x = chartPadding + (i * (barActualWidth + barSpacing));
                const y = chartHeight + chartPadding - barHeight;

                ctx.fillStyle = '#6366f1'; // Indigo 500
                ctx.fillRect(x, y, barActualWidth, barHeight);

                // Draw labels (date/week/month)
                ctx.fillStyle = '#333';
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(chartLabels[i], x + barActualWidth / 2, chartHeight + chartPadding + 20);

                // Draw data value on top of bar
                if (barValue > 0) {
                    ctx.fillText(barValue, x + barActualWidth / 2, y - 5);
                }
            }

            // Y-axis label
            ctx.save();
            ctx.translate(chartPadding / 2, chartHeight / 2 + chartPadding);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Tasks Completed', 0, 0);
            ctx.restore();

            // X-axis label
            ctx.textAlign = 'center';
            ctx.fillText('Period', chartWidth / 2 + chartPadding, chartHeight + chartPadding + 40);

            // Max value on Y-axis
            ctx.textAlign = 'right';
            ctx.fillText(maxYValue, chartPadding - 5, chartPadding + 5);
            ctx.fillText('0', chartPadding - 5, chartHeight + chartPadding + 5);
        }

        clearProgressHistoryBtn.addEventListener('click', () => {
            if (confirm("Are you sure you want to clear all your progress history? This action cannot be undone.")) {
                localStorage.removeItem(DAILY_PROGRESS_KEY);
                renderProgressChart(currentProgressView); // Re-render empty chart
                alert("Progress history cleared!");
            }
        });

        // --- Initial Load ---
        window.onload = () => {
            // Set canvas dimensions for timer
            timerCanvas.width = timerCanvas.offsetWidth;
            timerCanvas.height = timerCanvas.offsetHeight;

            loadChecklistState(); // This will handle daily reset and recording previous day's progress
            loadTimerState();
            // Show checklist tab by default
            showTab('checklist');
            showProgressView('daily'); // Initialize daily view for progress tab
        };

        // Re-render chart on window resize for responsiveness
        window.addEventListener('resize', () => {
            if (!progressSection.classList.contains('hidden')) {
                renderProgressChart(currentProgressView);
            }
            if (!timerSection.classList.contains('hidden')) {
                timerCanvas.width = timerCanvas.offsetWidth;
                timerCanvas.height = timerCanvas.offsetHeight;
                drawTimerCircle(timerCtx, timeRemaining, totalTimerSeconds);
            }
        });
    </script>
</body>
</html>
